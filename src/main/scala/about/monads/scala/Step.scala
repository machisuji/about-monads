package about.monads.scala

import java.util.StringTokenizer

/**
 * Parse Step monad.
 */
abstract sealed trait Step {
  /**
   * Monad value made up of the current value of the computation and
   * the remaining tokens to be parsed.
   *
   * The generic type of this monad would be M[(Option[String], List[String])].
   **/
  val value: Option[String]
  val tokens: List[String]

  /**
   * Monadic bind, that is: unwrap value, possibly do something with it, wrap it up again
   *
   * Example: step flatMap ((_: Option[String], _: List[String]) => Reject("no", Nil))
   *
   *   Which does simply discard all of the previous computation and returns the
   *   zero (Reject) of the Step monad.
   *
   * This is all takes for a structure to be a monad along with the monadic unit,
   * that is: wrap a value ( (Option[String], List[String]) ) up in the monad
   *
   * Example: Accept(None, List("1", "+", "1"))
   *
   *   This means Accept#apply, which is generated by the compiler since Accept is a case
   *   class, is the monadic unit of the Step monad.
   **/
  def flatMap(f: (Option[String], List[String]) => Step): Step

  /** Haskell alias for bind **/
  def >>=(f: (Option[String], List[String]) => Step): Step = flatMap(f)

  /** This already leads beyond monads into another structure. **/
  def orElse(step: Step): Step
}

object Step {
  def apply(tokens: String) = {
    val tk = new StringTokenizer(tokens, " +-*/()", true)
    Accept(None, Iterator.continually(tk).takeWhile(
      _.hasMoreTokens).map(_.nextToken).filter(" " !=).toList)
  }
}

case class Accept(value: Option[String], tokens: List[String]) extends Step {
  def flatMap(f: (Option[String], List[String]) => Step): Step = f(value, tokens)

  /**
   * (Accept1 orElse Accept2) == Accept1
   */
  def orElse(step: Step) = this
}

object Accept {
  def apply(tokens: List[String]): Accept = Accept(None, tokens)
}

/**
 * Monadic zero. Binding (flatMap-ping) a zero results in a zero independently
 * from the passed function. The function will not be called, since the zero
 * does not contain any value.
 *
 * Think (0 * anything) is still 0.
 */
case class Reject(error: String, tokens: List[String]) extends Step {
  val value = None

  def flatMap(f: (Option[String], List[String]) => Step): Step = this

  /**
   * (Reject orElse Accept) == (Accept orElse Reject) == Accept
   */
  def orElse(step: Step) = step
}
